<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS2 Spectator UI</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/babel-standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>

<body class="bg-gray-900 text-white">
    <div id="root" class="min-h-screen"></div>

    <script type="text/babel">
        const CS2SpectatorUI = () => {
            const [playerData, setPlayerData] = React.useState([]);
            const [selectedPlayer, setSelectedPlayer] = React.useState(null);
            const [selectedMap, setSelectedMap] = React.useState(null);
            const [availableMaps, setAvailableMaps] = React.useState([]);
            const [mapConfig, setMapConfig] = React.useState(null);
            const [showLowerLevel, setShowLowerLevel] = React.useState(false);
            const [connectionStatus, setConnectionStatus] = React.useState('connecting');
            const [mapImage, setMapImage] = React.useState(null);

            const canvasRef = React.useRef(null);
            const canvasContainerRef = React.useRef(null);

            React.useEffect(() => {
                if (!selectedMap) return;

                const img = new Image();
                img.src = `/cs2-radar-images/${selectedMap}${showLowerLevel ? '_lower' : ''}_radar_psd.png`;
                img.onload = () => {
                    setMapImage(img);
                };
                img.onerror = () => {
                    const defaultImg = new Image();
                    defaultImg.src = '/cs2-radar-images/default_png.png';
                    defaultImg.onload = () => {
                        setMapImage(defaultImg);
                    };
                };

                setShowLowerLevel(false);
            }, [selectedMap]);

            React.useEffect(() => {
                if (!selectedMap) return;

                const img = new Image();
                img.src = `/cs2-radar-images/${selectedMap}${showLowerLevel ? '_lower' : ''}_radar_psd.png`;
                img.onload = () => {
                    setMapImage(img);
                };
                img.onerror = () => {
                    const defaultImg = new Image();
                    defaultImg.src = '/cs2-radar-images/default_png.png';
                    defaultImg.onload = () => {
                        setMapImage(defaultImg);
                    };
                };
            }, [showLowerLevel]);

            React.useEffect(() => {
                if (!canvasRef.current || !mapImage || !mapConfig) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');

                const container = canvasContainerRef.current;
                if (!container) return;

                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;

                const dpr = window.devicePixelRatio || 1;
                canvas.width = containerWidth * dpr;
                canvas.height = containerHeight * dpr;

                ctx.scale(dpr, dpr);

                ctx.clearRect(0, 0, containerWidth, containerHeight);

                const mapAspectRatio = mapImage.width / mapImage.height;
                let drawWidth, drawHeight, drawX, drawY;

                if (containerWidth / containerHeight > mapAspectRatio) {
                    drawHeight = containerHeight;
                    drawWidth = drawHeight * mapAspectRatio;
                    drawX = (containerWidth - drawWidth) / 2;
                    drawY = 0;
                } else {
                    drawWidth = containerWidth;
                    drawHeight = drawWidth / mapAspectRatio;
                    drawX = 0;
                    drawY = (containerHeight - drawHeight) / 2;
                }

                ctx.save();

                if (selectedPlayer) {
                    if (mapConfig.verticalSections && mapConfig.verticalSections.lower) {
                        const lowerThreshold = mapConfig.verticalSections.lower.altitudeMax;
                        if (selectedPlayer.position.z < lowerThreshold - 10 && !showLowerLevel) {
                            setShowLowerLevel(true);
                        } else if (selectedPlayer.position.z > lowerThreshold + 10 && showLowerLevel) {
                            setShowLowerLevel(false);
                        }
                    }
                }

                if (mapConfig.rotate) {
                    ctx.translate(containerWidth / 2, containerHeight / 2);

                    const rotationAngle = mapConfig.rotate === 0 ? Math.PI / 2 :
                        mapConfig.rotate === 1 ? Math.PI : 0;
                    ctx.rotate(rotationAngle);

                    if (mapConfig.rotate === 0 || mapConfig.rotate === 1) {
                        const temp = drawWidth;
                        drawWidth = drawHeight;
                        drawHeight = temp;
                    }

                    ctx.drawImage(mapImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                } else {
                    ctx.drawImage(mapImage, drawX, drawY, drawWidth, drawHeight);
                }

                ctx.restore();

                playerData.forEach(player => {
                    if (player.life_state !== 0) return;

                    const position = calculatePlayerCanvasPosition(player, drawX, drawY, drawWidth, drawHeight);

                    ctx.beginPath();
                    ctx.arc(position.x, position.y, 8, 0, 2 * Math.PI);

                    switch (player.team) {
                        case 2: ctx.fillStyle = '#CA8A04'; break; // Terrorists (yellow-600)
                        case 3: ctx.fillStyle = '#2563EB'; break; // Counter-Terrorists (blue-600)
                        default: ctx.fillStyle = '#4B5563'; break; // Spectator (gray-600)
                    }

                    ctx.fill();

                    if (player.active_player) {
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }

                    ctx.font = '12px Arial';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.fillText(player.name, position.x, position.y + 20);
                });

            }, [playerData, mapImage, mapConfig, canvasRef.current]);

            React.useEffect(() => {
                const handleResize = () => {
                    if (!canvasRef.current || !mapImage || !mapConfig) return;

                    const canvas = canvasRef.current;
                    const container = canvasContainerRef.current;
                    if (!container) return;

                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;

                    const dpr = window.devicePixelRatio || 1;
                    canvas.width = containerWidth * dpr;
                    canvas.height = containerHeight * dpr;

                    setPlayerData([...playerData]);
                };

                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, [playerData, mapImage, mapConfig]);

            React.useEffect(() => {
                let ws = null;
                let reconnectTimeout = null;

                const connectWebSocket = () => {
                    setConnectionStatus('connecting');

                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                        reconnectTimeout = null;
                    }

                    ws = new WebSocket(`ws://${window.location.hostname}:8080/ws`);

                    ws.onopen = () => {
                        setConnectionStatus('connected');
                        console.log('WebSocket connection established');
                    };

                    ws.onmessage = (event) => {
                        try {
                            const message = JSON.parse(event.data);

                            if (message.type === "maps_list") {
                                setAvailableMaps(message.maps);
                                if (message.maps.length > 0) {
                                    if (!selectedMap) {
                                        setSelectedMap(message.maps[0].id);
                                        setMapConfig(message.maps[0]);
                                    }
                                }
                                return;
                            }

                            if (message.type === "player_data") {
                                setPlayerData(message.data);
                                return;
                            }

                            console.warn("Unknown message type:", message.type);
                        } catch (error) {
                            console.error("Error parsing data:", error);
                        }
                    };

                    ws.onclose = () => {
                        setConnectionStatus('disconnected');
                        console.log("WebSocket connection closed, attempting to reconnect...");

                        reconnectTimeout = setTimeout(connectWebSocket, 3000);
                    };

                    ws.onerror = (error) => {
                        setConnectionStatus('error');
                        console.error("WebSocket error:", error);
                    };
                };

                connectWebSocket();

                return () => {
                    if (ws) {
                        ws.close();
                    }

                    if (reconnectTimeout) {
                        clearTimeout(reconnectTimeout);
                    }
                };
            }, []);

            React.useEffect(() => {
                if (!selectedMap || !availableMaps.length) return;

                const newConfig = availableMaps.find(m => m.id === selectedMap);
                if (newConfig) {
                    setMapConfig(newConfig);
                }
            }, [selectedMap, availableMaps]);

            const calculatePlayerCanvasPosition = (player, drawX, drawY, drawWidth, drawHeight) => {
                if (!mapConfig) {
                    return { x: drawX + drawWidth / 2, y: drawY + drawHeight / 2 };
                }

                const scale = 1 / mapConfig.scale;

                let gameX = (player.position.x - mapConfig.pos_x) * scale;
                let gameY = -(player.position.y - mapConfig.pos_y) * scale;

                gameX = gameX / 1024;
                gameY = gameY / 1024;

                let canvasX = drawX + (gameX * drawWidth);
                let canvasY = drawY + (gameY * drawHeight);

                if (mapConfig.rotate) {
                    const centerX = drawX + drawWidth / 2;
                    const centerY = drawY + drawHeight / 2;

                    const translatedX = canvasX - centerX;
                    const translatedY = canvasY - centerY;

                    let rotatedX, rotatedY;
                    if (mapConfig.rotate === 0) {
                        rotatedX = -translatedY;
                        rotatedY = translatedX;
                    } else if (mapConfig.rotate === 1) {
                        rotatedX = -translatedX;
                        rotatedY = -translatedY;
                    } else {
                        rotatedX = translatedX;
                        rotatedY = translatedY;
                    }

                    canvasX = centerX + rotatedX;
                    canvasY = centerY + rotatedY;
                }

                return {
                    x: canvasX,
                    y: canvasY
                };
            };

            const handleCanvasClick = (e) => {
                if (!canvasRef.current || !playerData.length) return;

                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                let closestPlayer = null;
                let closestDistance = Infinity;

                playerData.forEach(player => {
                    if (player.life_state !== 0) return;

                    const container = canvasContainerRef.current;
                    if (!container) return;

                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;

                    const mapAspectRatio = mapImage ? mapImage.width / mapImage.height : 1;
                    let drawWidth, drawHeight, drawX, drawY;

                    if (containerWidth / containerHeight > mapAspectRatio) {
                        drawHeight = containerHeight;
                        drawWidth = drawHeight * mapAspectRatio;
                        drawX = (containerWidth - drawWidth) / 2;
                        drawY = 0;
                    } else {
                        drawWidth = containerWidth;
                        drawHeight = drawWidth / mapAspectRatio;
                        drawX = 0;
                        drawY = (containerHeight - drawHeight) / 2;
                    }

                    const position = calculatePlayerCanvasPosition(player, drawX, drawY, drawWidth, drawHeight);
                    const distance = Math.sqrt(Math.pow(position.x - x, 2) + Math.pow(position.y - y, 2));

                    if (distance < closestDistance) {
                        closestDistance = distance;
                        closestPlayer = player;
                    }
                });

                if (closestDistance < 20 && closestPlayer) {
                    setSelectedPlayer(closestPlayer);
                }
            };

            const handlePlayerClick = (player) => {
                if (player === selectedPlayer) {
                    setSelectedPlayer(null);
                    return;
                }
                setSelectedPlayer(player);
            };

            const handleMapChange = (e) => {
                setSelectedMap(e.target.value);
            };

            const hasLowerLevel = mapConfig && mapConfig.verticalSections && mapConfig.verticalSections.lower !== undefined;

            const getTeamName = (teamId) => {
                switch (teamId) {
                    case 2: return "Terrorists";
                    case 3: return "Counter-Terrorists";
                    default: return "Spectator";
                }
            };

            const getTeamColor = (teamId) => {
                switch (teamId) {
                    case 2: return "bg-yellow-600";
                    case 3: return "bg-blue-600";
                    default: return "bg-gray-600";
                }
            };

            const getWeaponName = (weaponId) => {
                return weaponId.replace('weapon_', '');
            };

            return (
                <div className="flex flex-col h-screen p-4 bg-gray-900 text-white overflow-hidden">
                    <div className="flex justify-between items-center mb-2">
                        <h1 className="text-2xl font-bold">CS2 Live Spectator</h1>

                        <div className="flex items-center">
                            <div className="flex items-center mr-4">
                                <div className={`w-3 h-3 rounded-full mr-2 ${connectionStatus === 'connected' ? 'bg-green-500' :
                                    connectionStatus === 'connecting' ? 'bg-yellow-500' :
                                        'bg-red-500'
                                    }`}></div>
                                <span className="text-sm">
                                    {connectionStatus === 'connected' ? 'Connected' :
                                        connectionStatus === 'connecting' ? 'Connecting...' :
                                            'Disconnected'}
                                </span>
                            </div>

                            <div className="flex items-center">
                                <select
                                    className="bg-gray-800 text-white py-1 px-3 rounded mr-2"
                                    value={selectedMap || ''}
                                    onChange={handleMapChange}
                                >
                                    {availableMaps.map(map => (
                                        <option key={map.id} value={map.id}>
                                            {map.name}
                                        </option>
                                    ))}
                                </select>
                            </div>
                        </div>
                    </div>

                    <div className="flex flex-row h-full gap-4">
                        <div className="w-2/3 bg-gray-800 rounded-lg p-4 flex flex-col">
                            <h2 className="text-xl font-semibold mb-2">Map</h2>
                            <div ref={canvasContainerRef} className="relative flex-grow bg-gray-700 rounded overflow-hidden">
                                <canvas
                                    ref={canvasRef}
                                    onClick={handleCanvasClick}
                                    className="cursor-pointer"
                                />
                            </div>

                            {selectedPlayer ? (
                                <div className="bg-gray-700 rounded-lg p-2 mt-4">
                                    <h3 className="font-semibold mb-1 flex items-center">
                                        <span className={`w-2 h-2 rounded-full ${getTeamColor(selectedPlayer.team)} mr-2`}></span>
                                        {selectedPlayer.name} ({getTeamName(selectedPlayer.team)})
                                    </h3>

                                    <div className="grid grid-cols-3 gap-2 text-sm">
                                        <div>
                                            <span className="text-gray-400">Health:</span> {selectedPlayer.health}
                                        </div>
                                        <div>
                                            <span className="text-gray-400">Armor:</span> {selectedPlayer.armor}
                                        </div>
                                        <div>
                                            <span className="text-gray-400">Money:</span> ${selectedPlayer.money}
                                        </div>
                                        <div>
                                            <span className="text-gray-400">EQP value:</span> {selectedPlayer.freezetime_end_equipment_value}
                                        </div>
                                        <div>
                                            <span className="text-gray-400">Weapon:</span> {getWeaponName(selectedPlayer.weapon)}
                                        </div>
                                        <div>
                                            <span className="text-gray-400">X:</span> {selectedPlayer.position.x.toFixed(0)}
                                        </div>
                                        <div>
                                            <span className="text-gray-400">Y:</span> {selectedPlayer.position.y.toFixed(0)}
                                        </div>
                                    </div>
                                </div>
                            ) :
                                <div className="bg-gray-700 rounded-lg p-2 mt-4">
                                    <div className="grid grid-cols-3 gap-2 text-sm">
                                        <h3 className="font-semibold mb-1 flex items-center">
                                            <span className="w-2 h-2 rounded-full bg-yellow-600 mr-2"></span>
                                            {playerData.filter(player => player.team === 2 && player.life_state === 0).length} Terrorists
                                        </h3>
                                        <h4>vs</h4>
                                        <h3 className="font-semibold mb-1 flex items-center">
                                            <span className="w-2 h-2 rounded-full bg-blue-600 mr-2"></span>
                                            {playerData.filter(player => player.team === 3 && player.life_state === 0).length} Counter-Terrorists
                                        </h3>
                                    </div>

                                    <div className="grid grid-cols-3 gap-2 text-sm">
                                        <div>
                                            <span className="text-yellow-600">T Unfreeze EQP value:</span> {playerData.map(p => p.team === 2 ? p.freezetime_end_equipment_value : 0).reduce((p, c) => p + c, 0)}
                                        </div><p></p>
                                        <div>
                                            <span className="text-blue-600">CT Unfreeze EQP value:</span> {playerData.map(p => p.team === 3 ? p.freezetime_end_equipment_value : 0).reduce((p, c) => p + c, 0)}
                                        </div>
                                    </div>
                                </div>}
                        </div>

                        <div className="w-1/3 bg-gray-800 rounded-lg p-4 overflow-y-auto">
                            <h2 className="text-xl font-semibold mb-2">Players</h2>
                            <div className="space-y-2">
                                {playerData.map(player => (
                                    <div
                                        key={player.name}
                                        className={`relative p-2 rounded-md cursor-pointer ${selectedPlayer && player.name === selectedPlayer.name ? 'ring-2 ring-white' : ''} ${getTeamColor(player.team)}`}
                                        onClick={() => handlePlayerClick(player)}
                                    >
                                        <div className="flex justify-between items-center">
                                            <div className="font-bold flex items-center">
                                                {player.active_player && <span className="mr-1">👁️</span>}
                                                {player.name}
                                            </div>
                                            <div className="text-sm">
                                                ${player.money}
                                            </div>
                                        </div>

                                        <div className="flex items-center mt-1">
                                            <div className="w-20 bg-gray-700 h-3 rounded-sm mr-2">
                                                <div
                                                    className={`h-3 rounded-sm ${player.health > 60 ? 'bg-green-500' :
                                                        player.health > 20 ? 'bg-yellow-500' : 'bg-red-500'
                                                        }`}
                                                    style={{ width: `${player.health}%` }}
                                                />
                                            </div>

                                            {player.armor > 0 && (
                                                <div className="w-5 h-5 bg-gray-300 rounded-full flex items-center justify-center text-gray-800 text-xs">
                                                    {player.armor}
                                                </div>
                                            )}

                                            <div className="ml-2 text-xs">
                                                {getWeaponName(player.weapon)}
                                            </div>
                                        </div>

                                        {player.life_state !== 0 && (
                                            <div className="absolute inset-0 bg-black bg-opacity-70 rounded-md flex items-center justify-center">
                                                <span className="text-red-500 font-bold text-lg">DEAD</span>
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        </div>
                    </div>
                </div >
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<CS2SpectatorUI />);
    </script>
</body>

</html>